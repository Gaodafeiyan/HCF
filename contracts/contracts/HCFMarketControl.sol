// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IHCFToken {
    function transfer(address to, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function burn(uint256 amount) external;
}

interface IPriceOracle {
    function getPrice() external view returns (uint256);
    function updatePrice() external;
}

interface IHCFStaking {
    function updatePriceImpact(uint256 _priceChangePercent) external;
    function getAntiDumpStatus() external view returns (uint256, uint256, uint256);
}

interface IHCFNodeNFT {
    function distributeAntiDumpRewards(uint256 _amount) external;
}

/**
 * @title HCFMarketControl
 * @dev 防暴跌市场控制系统
 * 
 * 功能包括:
 * - 防暴跌机制 (动态税收调整)
 * - 减产机制 (质押收益调整)
 * - 房损保护 (损失补偿)
 * - 控盘燃烧 (自动燃烧机制)
 * - 价格监控和预警
 */
contract HCFMarketControl is Ownable, ReentrancyGuard {
    
    // ============ 状态变量 ============
    
    IHCFToken public hcfToken;
    IPriceOracle public priceOracle;
    IHCFStaking public stakingContract;
    IHCFNodeNFT public nodeNFT;
    
    // 900万调控底池
    uint256 public constant CONTROL_POOL = 9_000_000 * 10**18; // 900万HCF调控池
    uint256 public controlPoolUsed; // 已使用的调控资金
    uint256 public controlPoolAvailable; // 可用调控资金
    
    // 价格监控
    uint256 public currentPrice;
    uint256 public previousPrice;
    uint256 public priceUpdateTime;
    uint256 public constant PRICE_UPDATE_INTERVAL = 1 hours;
    uint256 public targetPrice = 1 * 10**18; // 目标价格 1 USD
    uint256 public interventionCooldown = 3600; // 干预冷却时间
    
    // 防暴跌参数
    struct AntiDumpConfig {
        uint256 threshold10;        // 10%跌幅阈值
        uint256 threshold30;        // 30%跌幅阈值  
        uint256 threshold50;        // 50%跌幅阈值
        uint256 additionalTax10;    // 10%跌幅额外税收 (5%)
        uint256 additionalTax30;    // 30%跌幅额外税收 (15%)
        uint256 additionalTax50;    // 50%跌幅额外税收 (30%)
        uint256 burnRate10;         // 10%跌幅燃烧率 (3%)
        uint256 burnRate30;         // 30%跌幅燃烧率 (10%)
        uint256 burnRate50;         // 50%跌幅燃烧率 (20%)
        uint256 nodeRate10;         // 10%跌幅节点分红 (2%)
        uint256 nodeRate30;         // 30%跌幅节点分红 (5%)
        uint256 nodeRate50;         // 50%跌幅节点分红 (10%)
    }
    
    AntiDumpConfig public antiDumpConfig;\n    \n    // 减产机制参数\n    struct ProductionConfig {\n        uint256 reductionRate10;    // 10%跌幅减产率 (5%)\n        uint256 reductionRate30;    // 30%跌幅减产率 (15%)\n        uint256 reductionRate50;    // 50%跌幅减产率 (30%)\n        uint256 recoveryTime;       // 恢复时间 (24小时)\n        uint256 lastReductionTime;  // 最后减产时间\n    }\n    \n    ProductionConfig public productionConfig;\n    \n    // 房损保护参数\n    struct LossProtectionConfig {\n        uint256 protectionThreshold;    // 保护阈值 (30%)\n        uint256 compensationRate;       // 补偿率 (50%)\n        uint256 maxCompensation;        // 单次最大补偿\n        uint256 protectionPool;         // 保护资金池\n        mapping(address => uint256) userLossRecord; // 用户损失记录\n        mapping(address => uint256) lastClaimTime;  // 最后申请时间\n    }\n    \n    LossProtectionConfig public lossProtection;\n    \n    // 控盘燃烧参数\n    struct BurnConfig {\n        uint256 priceStabilityBurn;     // 价格稳定燃烧率\n        uint256 volumeBurn;             // 交易量燃烧率\n        uint256 timeBurn;               // 定时燃烧率\n        uint256 lastBurnTime;           // 最后燃烧时间\n        uint256 burnInterval;           // 燃烧间隔 (24小时)\n        uint256 totalBurned;            // 总燃烧量\n    }\n    \n    BurnConfig public burnConfig;\n    \n    // 当前市场状态\n    enum MarketState { NORMAL, DUMP_10, DUMP_30, DUMP_50 }\n    MarketState public currentMarketState = MarketState.NORMAL;\n    \n    // 紧急模式\n    bool public emergencyMode = false;\n    uint256 public emergencyActivationTime;\n    \n    // 交易量监控\n    uint256 public dailyVolume;\n    uint256 public lastVolumeResetTime;\n    uint256 public constant VOLUME_RESET_INTERVAL = 24 hours;\n    \n    // ============ 事件 ============\n    \n    event PriceUpdated(uint256 newPrice, uint256 oldPrice, uint256 changePercent);\n    event MarketStateChanged(MarketState oldState, MarketState newState);\n    event AntiDumpTriggered(uint256 priceImpact, uint256 additionalTax, uint256 burnAmount);\n    event ProductionReduced(uint256 reductionRate, uint256 duration);\n    event LossCompensation(address indexed user, uint256 lossAmount, uint256 compensation);\n    event ControlBurnExecuted(uint256 burnAmount, string burnType);\n    event EmergencyModeActivated(uint256 activationTime);\n    event EmergencyModeDeactivated(uint256 deactivationTime);\n    \n    // ============ 构造函数 ============\n    \n    constructor(\n        address _hcfToken,\n        address _priceOracle,\n        address _stakingContract,\n        address _nodeNFT\n    ) Ownable(msg.sender) {\n        hcfToken = IHCFToken(_hcfToken);\n        priceOracle = IPriceOracle(_priceOracle);\n        stakingContract = IHCFStaking(_stakingContract);\n        nodeNFT = IHCFNodeNFT(_nodeNFT);\n        \n        _initializeConfigs();\n    }\n    \n    function _initializeConfigs() internal {\n        // 防暴跌配置\n        antiDumpConfig = AntiDumpConfig({\n            threshold10: 1000,      // 10%\n            threshold30: 3000,      // 30%\n            threshold50: 5000,      // 50%\n            additionalTax10: 500,   // 5%\n            additionalTax30: 1500,  // 15%\n            additionalTax50: 3000,  // 30%\n            burnRate10: 300,        // 3%\n            burnRate30: 1000,       // 10%\n            burnRate50: 2000,       // 20%\n            nodeRate10: 200,        // 2%\n            nodeRate30: 500,        // 5%\n            nodeRate50: 1000        // 10%\n        });\n        \n        // 减产机制配置\n        productionConfig = ProductionConfig({\n            reductionRate10: 500,       // 5%\n            reductionRate30: 1500,      // 15%\n            reductionRate50: 3000,      // 30%\n            recoveryTime: 24 hours,\n            lastReductionTime: 0\n        });\n        \n        // 房损保护配置\n        lossProtection.protectionThreshold = 3000;     // 30%\n        lossProtection.compensationRate = 5000;        // 50%\n        lossProtection.maxCompensation = 10000 * 10**18; // 10000 HCF\n        \n        // 控盘燃烧配置\n        burnConfig = BurnConfig({\n            priceStabilityBurn: 100,    // 1%\n            volumeBurn: 50,             // 0.5%\n            timeBurn: 200,              // 2%\n            lastBurnTime: block.timestamp,\n            burnInterval: 24 hours,\n            totalBurned: 0\n        });\n    }\n    \n    // ============ 价格监控和更新 ============\n    \n    /**\n     * @dev 更新价格并触发相应机制\n     */\n    function updatePrice() external {\n        require(\n            block.timestamp >= priceUpdateTime + PRICE_UPDATE_INTERVAL || \n            msg.sender == owner(),\n            \"Too early to update\"\n        );\n        \n        previousPrice = currentPrice;\n        currentPrice = priceOracle.getPrice();\n        priceUpdateTime = block.timestamp;\n        \n        if (previousPrice > 0) {\n            uint256 priceChange = _calculatePriceChange();\n            _updateMarketState(priceChange);\n            \n            emit PriceUpdated(currentPrice, previousPrice, priceChange);\n        }\n    }\n    \n    function _calculatePriceChange() internal view returns (uint256) {\n        if (currentPrice >= previousPrice) {\n            return 0; // 价格上涨或持平\n        }\n        \n        uint256 decrease = previousPrice - currentPrice;\n        return (decrease * 10000) / previousPrice; // 返回基点 (bp)\n    }\n    \n    /**\n     * @dev 更新市场状态并触发相应机制\n     */\n    function _updateMarketState(uint256 _priceChange) internal {\n        MarketState oldState = currentMarketState;\n        MarketState newState = _determineMarketState(_priceChange);\n        \n        if (newState != oldState) {\n            currentMarketState = newState;\n            _triggerMarketMechanisms(_priceChange);\n            \n            emit MarketStateChanged(oldState, newState);\n        }\n    }\n    \n    function _determineMarketState(uint256 _priceChange) internal view returns (MarketState) {\n        if (_priceChange >= antiDumpConfig.threshold50) {\n            return MarketState.DUMP_50;\n        } else if (_priceChange >= antiDumpConfig.threshold30) {\n            return MarketState.DUMP_30;\n        } else if (_priceChange >= antiDumpConfig.threshold10) {\n            return MarketState.DUMP_10;\n        } else {\n            return MarketState.NORMAL;\n        }\n    }\n    \n    // ============ 市场控制机制 ============\n    \n    /**\n     * @dev 触发所有市场控制机制\n     */\n    function _triggerMarketMechanisms(uint256 _priceChange) internal {\n        if (currentMarketState != MarketState.NORMAL) {\n            _executeAntiDump(_priceChange);\n            _executeProductionReduction();\n            _executeControlBurn();\n            \n            // 通知质押合约更新参数\n            stakingContract.updatePriceImpact(_priceChange);\n        }\n    }\n    \n    /**\n     * @dev 执行防暴跌机制\n     */\n    function _executeAntiDump(uint256 _priceChange) internal {\n        (uint256 additionalTax, uint256 burnRate, uint256 nodeRate) = _getAntiDumpRates();\n        \n        // 计算燃烧量\n        uint256 burnAmount = (hcfToken.balanceOf(address(this)) * burnRate) / 10000;\n        if (burnAmount > 0) {\n            hcfToken.burn(burnAmount);\n        }\n        \n        // 分发节点奖励\n        uint256 nodeReward = (hcfToken.balanceOf(address(this)) * nodeRate) / 10000;\n        if (nodeReward > 0 && address(nodeNFT) != address(0)) {\n            nodeNFT.distributeAntiDumpRewards(nodeReward);\n        }\n        \n        emit AntiDumpTriggered(_priceChange, additionalTax, burnAmount);\n    }\n    \n    function _getAntiDumpRates() internal view returns (uint256, uint256, uint256) {\n        if (currentMarketState == MarketState.DUMP_50) {\n            return (antiDumpConfig.additionalTax50, antiDumpConfig.burnRate50, antiDumpConfig.nodeRate50);\n        } else if (currentMarketState == MarketState.DUMP_30) {\n            return (antiDumpConfig.additionalTax30, antiDumpConfig.burnRate30, antiDumpConfig.nodeRate30);\n        } else if (currentMarketState == MarketState.DUMP_10) {\n            return (antiDumpConfig.additionalTax10, antiDumpConfig.burnRate10, antiDumpConfig.nodeRate10);\n        }\n        return (0, 0, 0);\n    }\n    \n    /**\n     * @dev 执行减产机制\n     */\n    function _executeProductionReduction() internal {\n        uint256 reductionRate = _getProductionReductionRate();\n        \n        productionConfig.lastReductionTime = block.timestamp;\n        \n        emit ProductionReduced(reductionRate, productionConfig.recoveryTime);\n    }\n    \n    function _getProductionReductionRate() internal view returns (uint256) {\n        if (currentMarketState == MarketState.DUMP_50) {\n            return productionConfig.reductionRate50;\n        } else if (currentMarketState == MarketState.DUMP_30) {\n            return productionConfig.reductionRate30;\n        } else if (currentMarketState == MarketState.DUMP_10) {\n            return productionConfig.reductionRate10;\n        }\n        return 0;\n    }\n    \n    // ============ 房损保护机制 ============\n    \n    /**\n     * @dev 申请房损保护补偿\n     * @param _lossAmount 损失金额\n     */\n    function claimLossProtection(uint256 _lossAmount) external nonReentrant {\n        require(_lossAmount > 0, \"Loss amount must be positive\");\n        require(\n            block.timestamp >= lossProtection.lastClaimTime[msg.sender] + 24 hours,\n            \"Too early to claim again\"\n        );\n        \n        // 验证损失 (简化版本，实际需要更复杂的验证逻辑)\n        uint256 priceChange = _calculatePriceChange();\n        require(priceChange >= lossProtection.protectionThreshold, \"Price drop insufficient\");\n        \n        // 计算补偿\n        uint256 compensation = (_lossAmount * lossProtection.compensationRate) / 10000;\n        if (compensation > lossProtection.maxCompensation) {\n            compensation = lossProtection.maxCompensation;\n        }\n        \n        require(compensation <= lossProtection.protectionPool, \"Insufficient protection pool\");\n        \n        // 发放补偿\n        lossProtection.protectionPool -= compensation;\n        lossProtection.userLossRecord[msg.sender] += _lossAmount;\n        lossProtection.lastClaimTime[msg.sender] = block.timestamp;\n        \n        require(hcfToken.transfer(msg.sender, compensation), \"Compensation transfer failed\");\n        \n        emit LossCompensation(msg.sender, _lossAmount, compensation);\n    }\n    \n    /**\n     * @dev 向保护池注入资金\n     */\n    function fundProtectionPool(uint256 _amount) external {\n        require(hcfToken.transferFrom(msg.sender, address(this), _amount), \"Transfer failed\");\n        lossProtection.protectionPool += _amount;\n    }\n    \n    // ============ 控盘燃烧机制 ============\n    \n    /**\n     * @dev 执行控盘燃烧\n     */\n    function _executeControlBurn() internal {\n        uint256 burnAmount = _calculateControlBurnAmount();\n        \n        if (burnAmount > 0) {\n            hcfToken.burn(burnAmount);\n            burnConfig.totalBurned += burnAmount;\n            \n            emit ControlBurnExecuted(burnAmount, \"Anti-dump burn\");\n        }\n    }\n    \n    /**\n     * @dev 定时燃烧机制\n     */\n    function executeTimedBurn() external {\n        require(\n            block.timestamp >= burnConfig.lastBurnTime + burnConfig.burnInterval,\n            \"Too early for timed burn\"\n        );\n        \n        uint256 burnAmount = (hcfToken.balanceOf(address(this)) * burnConfig.timeBurn) / 10000;\n        \n        if (burnAmount > 0) {\n            hcfToken.burn(burnAmount);\n            burnConfig.totalBurned += burnAmount;\n            burnConfig.lastBurnTime = block.timestamp;\n            \n            emit ControlBurnExecuted(burnAmount, \"Timed burn\");\n        }\n    }\n    \n    function _calculateControlBurnAmount() internal view returns (uint256) {\n        uint256 balance = hcfToken.balanceOf(address(this));\n        return (balance * burnConfig.priceStabilityBurn) / 10000;\n    }\n    \n    // ============ 紧急模式 ============\n    \n    /**\n     * @dev 激活紧急模式\n     */\n    function activateEmergencyMode() external onlyOwner {\n        require(!emergencyMode, \"Already in emergency mode\");\n        \n        emergencyMode = true;\n        emergencyActivationTime = block.timestamp;\n        \n        // 紧急模式下的特殊参数\n        // TODO: 实现紧急模式特殊逻辑\n        \n        emit EmergencyModeActivated(block.timestamp);\n    }\n    \n    /**\n     * @dev 停用紧急模式\n     */\n    function deactivateEmergencyMode() external onlyOwner {\n        require(emergencyMode, \"Not in emergency mode\");\n        \n        emergencyMode = false;\n        \n        emit EmergencyModeDeactivated(block.timestamp);\n    }\n    \n    // ============ 查询函数 ============\n    \n    /**\n     * @dev 获取当前市场状态\n     */\n    function getMarketStatus() external view returns (\n        uint256 currentPrice_,\n        uint256 previousPrice_,\n        uint256 priceChange,\n        MarketState marketState,\n        bool emergencyMode_\n    ) {\n        return (\n            currentPrice,\n            previousPrice,\n            _calculatePriceChange(),\n            currentMarketState,\n            emergencyMode\n        );\n    }\n    \n    /**\n     * @dev 获取防暴跌状态\n     */\n    function getAntiDumpStatus() external view returns (\n        uint256 additionalTax,\n        uint256 burnRate,\n        uint256 nodeRate,\n        uint256 totalBurned\n    ) {\n        (additionalTax, burnRate, nodeRate) = _getAntiDumpRates();\n        totalBurned = burnConfig.totalBurned;\n    }\n    \n    /**\n     * @dev 获取房损保护状态\n     */\n    function getLossProtectionStatus(address _user) external view returns (\n        uint256 protectionPool,\n        uint256 userLossRecord,\n        uint256 lastClaimTime,\n        uint256 nextClaimTime\n    ) {\n        return (\n            lossProtection.protectionPool,\n            lossProtection.userLossRecord[_user],\n            lossProtection.lastClaimTime[_user],\n            lossProtection.lastClaimTime[_user] + 24 hours\n        );\n    }\n    \n    // ============ 管理函数 ============\n    \n    /**\n     * @dev 更新防暴跌配置\n     */\n    function updateAntiDumpConfig(\n        uint256[3] memory thresholds,\n        uint256[3] memory additionalTaxes,\n        uint256[3] memory burnRates,\n        uint256[3] memory nodeRates\n    ) external onlyOwner {\n        antiDumpConfig.threshold10 = thresholds[0];\n        antiDumpConfig.threshold30 = thresholds[1];\n        antiDumpConfig.threshold50 = thresholds[2];\n        \n        antiDumpConfig.additionalTax10 = additionalTaxes[0];\n        antiDumpConfig.additionalTax30 = additionalTaxes[1];\n        antiDumpConfig.additionalTax50 = additionalTaxes[2];\n        \n        antiDumpConfig.burnRate10 = burnRates[0];\n        antiDumpConfig.burnRate30 = burnRates[1];\n        antiDumpConfig.burnRate50 = burnRates[2];\n        \n        antiDumpConfig.nodeRate10 = nodeRates[0];\n        antiDumpConfig.nodeRate30 = nodeRates[1];\n        antiDumpConfig.nodeRate50 = nodeRates[2];\n    }\n    \n    /**\n     * @dev 更新合约地址\n     */\n    function updateContracts(\n        address _priceOracle,\n        address _stakingContract,\n        address _nodeNFT\n    ) external onlyOwner {\n        if (_priceOracle != address(0)) priceOracle = IPriceOracle(_priceOracle);\n        if (_stakingContract != address(0)) stakingContract = IHCFStaking(_stakingContract);\n        if (_nodeNFT != address(0)) nodeNFT = IHCFNodeNFT(_nodeNFT);\n    }\n    \n    /**\n     * @dev 紧急提取合约资金\n     */\n    function emergencyWithdraw(address _token, uint256 _amount) external onlyOwner {\n        require(emergencyMode, \"Must be in emergency mode\");\n        IERC20(_token).transfer(owner(), _amount);\n    }\n}